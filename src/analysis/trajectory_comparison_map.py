"""
Baseline vs. Shift trajectory comparison map generator for the analysis pipeline.

This module integrates with the targeted shift tester and hallucination detector
to automatically generate interactive HTML maps comparing baseline vs shifted trajectories.

Key features:
- Reads trajectory CSV files generated by MARLCollisionEnv with hallucination detection
- Creates interactive maps showing flight paths, conflicts, alerts, and safety events
- Integrates with viz_hooks for seamless visualization pipeline
- Supports batch processing of multiple shift configurations
"""

import os
import pandas as pd
import folium
import numpy as np
from typing import Dict, Any, List, Optional, Tuple
from pathlib import Path


def _read_traj_csv(csv_path: str) -> pd.DataFrame:
    """
    Read trajectory CSV file and return DataFrame.
    
    Expected columns from MARLCollisionEnv:
    - step_idx, agent_id, lat_deg, lon_deg, min_separation_nm
    - gt_conflict, predicted_alert, conflict_flag (from hallucination detection)
    - tp, fp, fn, tn (from confusion matrix analysis)
    """
    if not os.path.exists(csv_path):
        raise FileNotFoundError(f"Trajectory CSV not found: {csv_path}")
    
    df = pd.read_csv(csv_path)
    
    # Verify required columns exist
    required_cols = ['step_idx', 'agent_id', 'lat_deg', 'lon_deg']
    missing_cols = [col for col in required_cols if col not in df.columns]
    if missing_cols:
        raise ValueError(f"Missing required columns in {csv_path}: {missing_cols}")
    
    # Sort by step index for proper trajectory ordering
    df = df.sort_values(['step_idx', 'agent_id'])
    return df


def create_comparison_map(baseline_csv: str, shifted_csv: str, 
                         out_html: str = "comparison_map.html",
                         sep_nm: float = 5.0,
                         title: Optional[str] = None) -> bool:
    """
    Generate an HTML map comparing baseline vs shifted trajectories.
    
    Args:
        baseline_csv: Path to baseline trajectory CSV
        shifted_csv: Path to shifted trajectory CSV  
        out_html: Output HTML file path
        sep_nm: Separation threshold for LoS events (nautical miles)
        title: Optional custom title for the map
        
    Returns:
        True if successful, False otherwise
    """
    try:
        bdf = _read_traj_csv(baseline_csv)
        sdf = _read_traj_csv(shifted_csv)
    except Exception as e:
        print(f"Error reading trajectory files: {e}")
        return False
    
    # Center map at first baseline point
    if len(bdf) == 0:
        print("Error: Baseline trajectory is empty")
        return False
        
    lat0 = float(bdf['lat_deg'].iloc[0])
    lon0 = float(bdf['lon_deg'].iloc[0])
    
    # Create map with appropriate zoom
    m = folium.Map(location=[lat0, lon0], zoom_start=10, control_scale=True)
    
    # Add custom title if provided
    if title:
        title_html = f'''
        <h3 align="center" style="font-size:16px"><b>{title}</b></h3>
        '''
    else:
        title_html = '''
        <h3 align="center" style="font-size:16px"><b>Trajectory Comparison: Baseline vs Shifted</b></h3>
        '''
    m.get_root().add_child(folium.Element(title_html))

    def add_trajectory_tracks(df: pd.DataFrame, color: str, name: str, dash_pattern: Optional[str] = None):
        """Add trajectory tracks for all agents in the DataFrame."""
        for aid, agent_group in df.groupby('agent_id'):
            coords = agent_group[['lat_deg', 'lon_deg']].values.tolist()
            
            # Skip if no valid coordinates
            if not coords:
                continue
                
            # Create polyline for trajectory
            line_options = {
                'locations': coords,
                'color': color,
                'weight': 3,
                'opacity': 0.8,
                'tooltip': f"{name} {aid} trajectory ({len(coords)} points)"
            }
            
            if dash_pattern:
                line_options['dash_array'] = dash_pattern
                
            folium.PolyLine(**line_options).add_to(m)
            
            # Start marker (circle)
            folium.CircleMarker(
                location=coords[0],
                radius=6,
                color=color,
                fill=True,
                fillColor='white',
                fillOpacity=1.0,
                popup=f"{name} {aid} START<br>Position: {coords[0][0]:.4f}, {coords[0][1]:.4f}",
                tooltip=f"{name} {aid} START"
            ).add_to(m)
            
            # End marker
            folium.Marker(
                location=coords[-1],
                icon=folium.Icon(color='green' if 'BASELINE' in name else 'red', icon='stop'),
                popup=f"{name} {aid} END<br>Position: {coords[-1][0]:.4f}, {coords[-1][1]:.4f}",
                tooltip=f"{name} {aid} END"
            ).add_to(m)

    # Add baseline tracks (solid blue)
    add_trajectory_tracks(bdf, 'blue', 'BASELINE')
    
    # Add shifted tracks (dashed red)
    add_trajectory_tracks(sdf, 'red', 'SHIFTED', dash_pattern='10, 5')

    def add_safety_events(df: pd.DataFrame, label: str, color_scheme: Dict[str, str]):
        """Add LoS events, collisions, alerts, and hallucination detection results as map markers."""
        
        # LoS events (separation < threshold)
        if 'min_separation_nm' in df.columns:
            los_events = df[df['min_separation_nm'] < sep_nm].copy()
            for _, r in los_events.iterrows():
                folium.CircleMarker(
                    location=[r['lat_deg'], r['lon_deg']],
                    radius=5,
                    color=color_scheme['los'],
                    fill=True,
                    fillColor=color_scheme['los'],
                    fillOpacity=0.7,
                    popup=f"{label} LoS Event<br>Agent: {r['agent_id']}<br>Separation: {r['min_separation_nm']:.2f} NM<br>Step: {int(r['step_idx'])}",
                    tooltip=f"{label} LoS @ {r['min_separation_nm']:.2f} NM"
                ).add_to(m)
        
        # Collision candidates (separation < 1.0 NM)
        if 'min_separation_nm' in df.columns:
            collisions = df[df['min_separation_nm'] < 1.0].copy()
            for _, r in collisions.iterrows():
                folium.Marker(
                    location=[r['lat_deg'], r['lon_deg']],
                    icon=folium.Icon(color=color_scheme['collision'], icon='warning-sign'),
                    popup=f"{label} COLLISION RISK<br>Agent: {r['agent_id']}<br>Separation: {r['min_separation_nm']:.2f} NM<br>Step: {int(r['step_idx'])}",
                    tooltip=f"{label} COLLISION @ {r['min_separation_nm']:.2f} NM"
                ).add_to(m)
        
        # Predicted alerts from hallucination detector
        if 'predicted_alert' in df.columns:
            alerts = df[df['predicted_alert'] == 1].copy()
            for _, r in alerts.iterrows():
                folium.CircleMarker(
                    location=[r['lat_deg'], r['lon_deg']],
                    radius=4,
                    color=color_scheme['alert'],
                    fill=True,
                    fillColor='yellow',
                    fillOpacity=0.8,
                    popup=f"{label} PREDICTED ALERT<br>Agent: {r['agent_id']}<br>Step: {int(r['step_idx'])}",
                    tooltip=f"{label} Alert (step {int(r['step_idx'])})"
                ).add_to(m)
        
        # Ground truth conflicts
        if 'gt_conflict' in df.columns:
            gt_conflicts = df[df['gt_conflict'] == 1].copy()
            for _, r in gt_conflicts.iterrows():
                folium.CircleMarker(
                    location=[r['lat_deg'], r['lon_deg']],
                    radius=6,
                    color=color_scheme['gt_conflict'],
                    fill=True,
                    fillColor=color_scheme['gt_conflict'],
                    fillOpacity=0.6,
                    popup=f"{label} GROUND TRUTH CONFLICT<br>Agent: {r['agent_id']}<br>Step: {int(r['step_idx'])}",
                    tooltip=f"{label} GT Conflict"
                ).add_to(m)
        
        # True Positives (correct conflict detection)
        if 'tp' in df.columns:
            tp_events = df[df['tp'] == 1].copy()
            for _, r in tp_events.iterrows():
                folium.CircleMarker(
                    location=[r['lat_deg'], r['lon_deg']],
                    radius=4,
                    color='green',
                    fill=True,
                    fillColor='lightgreen',
                    fillOpacity=0.8,
                    popup=f"{label} TRUE POSITIVE<br>Agent: {r['agent_id']}<br>Step: {int(r['step_idx'])}",
                    tooltip=f"{label} TP"
                ).add_to(m)
        
        # False Positives (false alarms)
        if 'fp' in df.columns:
            fp_events = df[df['fp'] == 1].copy()
            for _, r in fp_events.iterrows():
                folium.CircleMarker(
                    location=[r['lat_deg'], r['lon_deg']],
                    radius=4,
                    color='orange',
                    fill=True,
                    fillColor='orange',
                    fillOpacity=0.8,
                    popup=f"{label} FALSE POSITIVE<br>Agent: {r['agent_id']}<br>Step: {int(r['step_idx'])}",
                    tooltip=f"{label} FP (Ghost Conflict)"
                ).add_to(m)

    # Color schemes for different event types
    baseline_colors = {
        'los': 'blue',
        'collision': 'red', 
        'alert': 'orange',
        'gt_conflict': 'purple'
    }
    
    shifted_colors = {
        'los': 'darkred',
        'collision': 'red',
        'alert': 'orange', 
        'gt_conflict': 'darkred'
    }

    # Add events for both trajectories
    add_safety_events(bdf, "BASELINE", baseline_colors)
    add_safety_events(sdf, "SHIFTED", shifted_colors)

    # Enhanced legend with hallucination detection elements
    legend_html = f'''
    <div style="position: fixed; 
                bottom: 50px; left: 50px; width: 320px; height: 220px; 
                background-color: white; border:2px solid grey; z-index:9999; 
                font-size:12px; padding: 10px">
    <h4>Legend</h4>
    <p><span style="color:blue; font-weight:bold">━━━</span> Baseline trajectory</p>
    <p><span style="color:red; font-weight:bold">- - -</span> Shifted trajectory</p>
    <p><span style="color:blue">●</span> LoS events (< {sep_nm} NM)</p>
    <p><span style="color:red">▲</span> Collision risk (< 1.0 NM)</p>
    <p><span style="color:orange">●</span> Predicted alerts</p>
    <p><span style="color:purple">●</span> Ground truth conflicts</p>
    <p><span style="color:green">●</span> True positives (TP)</p>
    <p><span style="color:orange">●</span> False positives (FP)</p>
    <p><small>Green markers = Start, Red markers = End</small></p>
    </div>
    '''
    
    m.get_root().add_child(folium.Element(legend_html))

    # Save the map
    try: 
        # Ensure output directory exists
        os.makedirs(os.path.dirname(os.path.abspath(out_html)), exist_ok=True)
        
        m.save(out_html)
        print(f"✅ Saved comparison map: {out_html}")
        
        # Print summary statistics
        print(f"\nComparison Summary:")
        print(f"Baseline trajectory points: {len(bdf)}")
        print(f"Shifted trajectory points: {len(sdf)}")
        
        if 'min_separation_nm' in bdf.columns:
            baseline_los = len(bdf[bdf['min_separation_nm'] < sep_nm])
            baseline_coll = len(bdf[bdf['min_separation_nm'] < 1.0])
            baseline_min_sep = bdf['min_separation_nm'].min()
            print(f"Baseline - LoS events: {baseline_los}, Collisions: {baseline_coll}, Min separation: {baseline_min_sep:.2f} NM")
        
        if 'min_separation_nm' in sdf.columns:
            shifted_los = len(sdf[sdf['min_separation_nm'] < sep_nm])
            shifted_coll = len(sdf[sdf['min_separation_nm'] < 1.0])
            shifted_min_sep = sdf['min_separation_nm'].min()
            print(f"Shifted - LoS events: {shifted_los}, Collisions: {shifted_coll}, Min separation: {shifted_min_sep:.2f} NM")
        
        # Hallucination detection summary
        if 'predicted_alert' in bdf.columns and 'predicted_alert' in sdf.columns:
            baseline_alerts = len(bdf[bdf['predicted_alert'] == 1])
            shifted_alerts = len(sdf[sdf['predicted_alert'] == 1])
            print(f"Alerts - Baseline: {baseline_alerts}, Shifted: {shifted_alerts}")
        
        if 'tp' in bdf.columns and 'fp' in bdf.columns:
            baseline_tp = len(bdf[bdf['tp'] == 1])
            baseline_fp = len(bdf[bdf['fp'] == 1])
            shifted_tp = len(sdf[sdf['tp'] == 1])
            shifted_fp = len(sdf[sdf['fp'] == 1])
            print(f"Detection - Baseline TP: {baseline_tp}, FP: {baseline_fp}")
            print(f"Detection - Shifted TP: {shifted_tp}, FP: {shifted_fp}")
            
        return True
        
    except Exception as e:
        print(f"Error saving map: {e}")
        return False


def generate_shift_comparison_maps(baseline_dir: str, shifts_dir: str, 
                                 viz_dir: str, sep_nm: float = 5.0) -> List[str]:
    """
    Generate comparison maps for all shift configurations vs baseline.
    
    Args:
        baseline_dir: Directory containing baseline trajectory CSV files
        shifts_dir: Directory containing shift subdirectories
        viz_dir: Output directory for visualization maps
        sep_nm: Separation threshold for LoS events
        
    Returns:
        List of generated HTML file paths
    """
    generated_maps = []
    
    # Ensure viz directory exists
    os.makedirs(viz_dir, exist_ok=True)
    
    # Find baseline CSV
    baseline_csvs = [f for f in os.listdir(baseline_dir) 
                    if f.startswith('traj_') and f.endswith('.csv')]
    
    if not baseline_csvs:
        print(f"Warning: No baseline trajectory CSV found in {baseline_dir}")
        return generated_maps
    
    baseline_csv = os.path.join(baseline_dir, baseline_csvs[0])  # Use first episode
    print(f"Using baseline trajectory: {baseline_csv}")
    
    # Process each shift configuration
    shift_dirs = [d for d in os.listdir(shifts_dir) 
                 if d != "baseline" and os.path.isdir(os.path.join(shifts_dir, d))]
    
    print(f"Generating comparison maps for {len(shift_dirs)} shift configurations...")
    
    for shift_name in sorted(shift_dirs):
        shift_dir = os.path.join(shifts_dir, shift_name)
        
        # Find trajectory CSV in shift directory
        shift_csvs = [f for f in os.listdir(shift_dir) 
                     if f.startswith('traj_') and f.endswith('.csv')]
        
        if not shift_csvs:
            print(f"Warning: No trajectory CSV found in {shift_dir}")
            continue
        
        shift_csv = os.path.join(shift_dir, shift_csvs[0])  # Use first episode
        output_html = os.path.join(viz_dir, f"comparison_baseline_vs_{shift_name}.html")
        
        # Create descriptive title
        title = f"Trajectory Comparison: Baseline vs {shift_name.replace('_', ' ').title()}"
        
        print(f"  Generating: {shift_name}")
        
        try:
            success = create_comparison_map(
                baseline_csv=baseline_csv,
                shifted_csv=shift_csv,
                out_html=output_html,
                sep_nm=sep_nm,
                title=title
            )
            
            if success:
                generated_maps.append(output_html)
                print(f"    ✅ Generated: comparison_baseline_vs_{shift_name}.html")
            else:
                print(f"    ❌ Failed to generate map for {shift_name}")
                
        except Exception as e:
            print(f"    ❌ Error generating map for {shift_name}: {e}")
    
    print(f"\n✅ Generated {len(generated_maps)} comparison maps in {viz_dir}")
    
    # Create index file for easy navigation
    create_comparison_maps_index(viz_dir, generated_maps)
    
    return generated_maps


def create_comparison_maps_index(viz_dir: str, map_files: List[str]):
    """Create an HTML index file for easy navigation of comparison maps."""
    
    index_html = os.path.join(viz_dir, "comparison_maps_index.html")
    
    html_content = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Trajectory Comparison Maps Index</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            h1 { color: #333; }
            .map-list { list-style-type: none; padding: 0; }
            .map-item { 
                margin: 10px 0; 
                padding: 10px; 
                border: 1px solid #ddd; 
                border-radius: 5px; 
                background-color: #f9f9f9;
            }
            .map-item a { 
                text-decoration: none; 
                color: #0066cc; 
                font-weight: bold;
            }
            .map-item a:hover { text-decoration: underline; }
            .description { color: #666; font-size: 0.9em; margin-top: 5px; }
        </style>
    </head>
    <body>
        <h1>Trajectory Comparison Maps</h1>
        <p>Interactive maps comparing baseline vs shifted aircraft trajectories with conflict detection analysis.</p>
        
        <ul class="map-list">
    """
    
    for map_file in map_files:
        map_name = os.path.basename(map_file)
        shift_name = map_name.replace('comparison_baseline_vs_', '').replace('.html', '')
        shift_display = shift_name.replace('_', ' ').title()
        
        html_content += f"""
            <li class="map-item">
                <a href="./{map_name}" target="_blank">{shift_display}</a>
                <div class="description">
                    Comparison of baseline trajectory vs {shift_display.lower()} configuration
                </div>
            </li>
        """
    
    html_content += """
        </ul>
        
        <hr>
        <p><small>Generated by trajectory_comparison_map.py as part of targeted shift analysis</small></p>
    </body>
    </html>
    """
    
    with open(index_html, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    print(f"✅ Created comparison maps index: {index_html}")